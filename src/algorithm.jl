
" The following initializes the master problem and runs a loop iterating between adding scenarios
and computing a solution for the current subset of scenarios. It is described in Algorithms 1 and 3 of the paper.
  * It is assumed throughout that the number of uncertain constraints is equal to data.ncons.
  * It is assumed throught that f(ξ,x) = ξᵀCx h(x).
  * Uncertain constraints are assumed to be linear functions g_ℓ(ξ,x) = ξᵀ(A_ℓ)x."

function scenario_generation(heuristic,warmup)
  # cc and aa record the uncertainty vectors ξ generated so far and multiplies them by the matrices C and A_ℓ.
  # Specifically:
  # cc[j,:] = Cᵀξ^j for each j in [m]
  # aa[ℓ][j,:] = Aᵀ_ℓ ξ^j for eacsh j in [m] and ℓ in [L]
  aa, cc = populate_scenarios()
  tΞ = [] #set of scenarios generated so far
  incumbent = []
  if !heuristic
    # If the algorithm is called in exact mode then a heuristic will be run first to obtain an upper bound
    # This upper bound serves to filter the set of solutions to be generated X(UB)
    if heuristicmode == "DUAL"
      @timeit to "heuristic" heurvalue,incumbent = heuristic_dualization()
    elseif heuristicmode == "HEURCG"
      @timeit to "heuristic" heurvalue,incumbent = scenario_generation(true,warmup)
    end
    # Current upper bound is set to the best solution value returned by the heuristic
    ub = heurvalue
    data.heuristic_ub = ub
    !warmup && @info "exact mode"
    # All the solutions in the set X(UB) are generated by using a problem-specific enumeration algorithm
    @timeit to "gen_sol" solutions = generate_solutions(ub)
  else
    # If the algoritm is called in heuristic mode then it is initalized simply with a set of solutions
    # Below this is done simply by starting with the optimal solution using the data of the first scenario and its neighbors
    !warmup && @info "heuristic mode"

    if data.constraint_uncertainty
      a_vec = aa[:][1,:]
    else
      a_vec = []
    end
    # A deterministic optimal solution is obtained using the data realization of first scenario
    detsol = find_new_solution(cc[1,:],a_vec,Inf,[],[],false,false,TIME_LIM)
    # The incumbent is initialized by creating k copies of this deterministic solution
    incumbent = Array{Int64}(undef, k, n)
    for k in K incumbent[k,:] = round_solution(detsol) end
    # The set of solutions is enriched by adding some neighbors of the incumbent
    @timeit to "gen_sol" solutions = generate_neighbors(incumbent,aa)
    # An initial (poor) upper bound is obtained by computing the robust cost of detsol
    ub = compute_basic_ub(detsol)
  end
  # In some pathological cases where the number of enumerated solutions is < k we add copies of the first solution
  for kk in (size(solutions,1)+1):k push!(solutions,solutions[1]) end
  # S is the number of solutions generated
  S = 1:size(solutions,1)
  # M is the number of scenarios added so far
  M = 1:size(cc,1)

  # Now we proceed to the iterations of the algorithm
  # solutions containts all solutions from X(UB) in the exact mode and a subset of these solutions in the heuristic mode

  # indicator new_scenario_added is used as a stopping criteria of convergence
  new_scenario_added = true

  # First initialize the structures that will be used throughout the algorithm
  # x_sol_array contains all solution vectors
  # sol_items contains the indices of non-zero variables in a solution vector
  x_sol_array = Vector{Vector{Float64}}()
  sol_items = Vector{Vector{Int}}()
  # Populate x_sol_array and sol_items using the enumerated solutions
  fill_solutions_bit(solutions, x_sol_array, sol_items)
  # The following vector contains h(x) for each x in X
  hh = [h(sol_items[s]) for s in S]
  # Starting lb: min_x∈X ξ^Tx for some ξ ∈ Ξ
  # In the following the initial scenario is used as ξ
  lb = minimum(sum(x_sol_array[s][l]*cc[1,l]*hh[s] for l in N) for s in S)

  # d records cost of each solution in each scenario, specifically
  # d[s,j] = ξ_jᵀCx_s h(x_s) for s in [r] and j in [m]
  d = Matrix{Float64}(undef,size(solutions,1),size(cc,1))
  # a_cov records constraint satisfaction of each solution in each scenario, specifically
  # (a_cov[ℓ][s,j] = 1) ⇔ (ξ_jᵀ(A_ℓ)x_s h(x_s) ≤ b_ℓ), for s in [r] and j in [m]
  a_cov = Vector{Matrix{Bool}}()
  if data.constraint_uncertainty
    for cons in 1:data.ncons
      push!(a_cov,Matrix{Bool}(undef,size(solutions,1),size(cc,1)))
    end
  end
  # initialize the number of iterations
  NUMITER = 0

  # calculate the initial gap
  gap = 100*round((ub - lb)/abs(ub), digits = 4)

  if time()-STARTTIME < TIME_LIM
    println("IT LB  UB  gap time")
    while new_scenario_added
      ξ = []
      NUMITER += 1
      if heuristic
        # In the heuristic mode d and a_cov are recalculated from scratch in each iteration
        # as this is not very costly with a small set of solutions
        @timeit to "re-calculate d" d = calculate_d(x_sol_array,cc,S,M,hh)
        if data.constraint_uncertainty
          @timeit to "re-calculate a_cov" a_cov = calculate_a(x_sol_array,aa,S,M)
        end
      else
        # In the exact mode d and a_cov are updated each time a new scenario is introduced
        # This permits reusing all d and a_cov values for the previously added scenarios
        @timeit to "update d" d = update_d(x_sol_array,cc,d,S,M,NUMITER,hh)
        if data.constraint_uncertainty
          @timeit to "update a_cov" a_cov = update_a(x_sol_array,aa,a_cov,S,M,NUMITER)
        end
      end
      # The master problem is solved using a binary search algorithm
      # It returns the current optimal solution and its value
      if !(data.constraint_uncertainty)
        @timeit to "binary search" x̃, ṽ_down, ṽ_up = binary_search(x_sol_array,sol_items,lb,ub,min(gap,1),d,a_cov,cc,δ)
      else
        @timeit to "binary search" x̃, ṽ_down, ṽ_up = binary_search(x_sol_array,sol_items,lb,ub,ϵ,d,a_cov,cc,δ)
      end

      # The optimal value of the master problem provides a lower bound
      lb = ṽ_down
      # If the master problem is solved succesfully then we proceed to the separation
      # If not then the binary search algorithm was stopped due to time limit restrictions
      # In this case it returns an empty solution permitting the algorithm to skip the separation step and break out of the while loop
      if length(x̃) > 0
        # Separation problem returns an identified scenario along with the separation objective value
        @timeit to "separation" ξ, sep_value = build_and_solve_separation(x̃, ṽ_up)
        # Because of the tolerance garantee when building the covcering matrix, it may happen that a given scenario be generated more than once
        # If that happens, we consider instead that the solution did not return any scenario.
        if data.constraint_uncertainty
          @timeit to "scenario generated?" begin
            if length(ξ) > 0 && length(tΞ) > 0
              for ξ′ in tΞ
                if norm(ξ-ξ′) < ϵ*min(norm(ξ),norm(ξ′))
                  @warn "scenario already generated"
                  ξ = []
                  sep_value = 0
                  break
                end
              end
            end
          end
        end
        length(ξ) > 0 && push!(tΞ,ξ)

        if !data.constraint_uncertainty
          # If there is no constraint uncertainty then upper bound updates are done whenever the separation value
          # improves upon the current bound. The upper bound is obtained simply as the separation value.
          # As the adversarial function is continuous this is a valid upper bound.
          if sep_value < ub  && sep_value > -Inf
            ub = sep_value
            incumbent = x̃
          end
        end
      end
      # Update the optimality gap
      gap = 100*round((ub - lb)/abs(ub), digits = 4)

      # If a scenario is returned from the separation problem and the convergence is not yet achieved
      # then add the realization of this scenario to vectors cc and aa.
      # Otherwise the indicator new_scenario_added is turned false to break out of the while loop.
      # The convergence is tested using the relative gap between ub and lb in the case where there is only objective uncertainty
      # and using the value returned by the function S(x̃,ṽ) in the case of contraint uncertainty
      if !(data.constraint_uncertainty)
        if length(ξ) == 0 || gap ≤ ϵ
          new_scenario_added = false
        end
      else
        if length(ξ) == 0 || sep_value ≤ ϵ
          new_scenario_added = false
        end
      end

      if new_scenario_added
        # We compute Cᵀξ and Aᵀ_ℓ ξ for the scenario ξ just obtained
        # println("Scenario added: $ξ")
        new_c, new_a = add_scenario(ξ)
        # M is increased by 1
        M = 1:(length(M)+1)
        # cc and aa are augmented with the new realization
        cc = [cc; new_c']
        if data.constraint_uncertainty
          for cons in 1:data.ncons
            aa[cons] = [aa[cons]; new_a[cons]']
          end
        end
      else
        # The current solution leads to S(x̃,ṽ) so the ub on its optimal value is an ub for the true problem
        ub = ṽ_up
        gap = 100*round((ub - lb)/abs(ub), digits = 4)
      end

      if heuristic && new_scenario_added
        # HEURISTIC MODE: the new scenario offers an opportunity to enrich the set of solutions
        if data.constraint_uncertainty
          a_vec = aa[:][end,:]
        else
          a_vec = []
        end
        # A good solution for the newly added scenario and its neighbors are added to the set of enumerated solutions
        @timeit to "relax and fix" new_solution = relax_and_fix(cc[end,:],a_vec,ub)

        if length(new_solution)>0
          @timeit to "generate neighbors" solutions_to_add = generate_neighbors(reshape(round_solution(new_solution),length(new_solution),1)',aa)
          for sol in solutions_to_add
            if !(sol in solutions)
              push!(solutions,sol)
            end
          end
        end
        # The following updates data-structures used throughout with the newly discovered solutions
        x_sol_array = Vector{Vector{Float64}}()
        sol_items = Vector{Vector{Int}}()
        fill_solutions_bit(solutions, x_sol_array, sol_items)
        S = 1:size(solutions,1)
        hh = [ h(sol_items[s]) for s in S ]
      end
      TotalTime = round(time()-STARTTIME, digits = 2)
      LowerBound = round(lb, digits = 4)
      println("$NUMITER $LowerBound $ub $gap $TotalTime")
      TotalTime > TIME_LIM && break
    end
  end
  if heuristic
    return ub,incumbent
  else
    return lb, ub, incumbent, gap, length(M), NUMITER, length(S)
  end
end

#-----------------------------------------------------------------------------------

"The following computes an optimal solution for the current set of scenarios using
a binary search algorithm based on the optimal solution cost, in line with the radius
formulation used for the p-center problem. It is described in Algorithm 2 of the paper."

function binary_search(x_sol_array,sol_items,lb,ub,ϵ_BS,d,a_cov,cc,δ)

  " For a given coverage matrix identify the non-dominated solutions."
  function calculate_nondom_solutions(cov,last,M,S)
    map = [BitSet([j for j in M if cov[s, j]]) for s in S]
    discarded = falses(length(S))
    for s in 1:(length(S)+1-k)
      if length(S)-length(discarded)==k break end
      if discarded[s] continue end
      for ss in 1:(length(S)+1-k)
        if s == ss continue
        elseif discarded[ss] continue
        elseif issubset(map[ss], map[s])
            discarded[ss] = true
            break
        elseif issubset(map[s], map[ss])
            discarded[s] = true
            break
        end
      end
    end
    SS = [s for s in S if !discarded[s]]
    return SS
  end

  " For a given coverage matrix identify the non-dominated scenarios."
  function calculate_nondom_scenarios(cov,M,S)
    map = [BitSet([s for s in S if cov[s, j]]) for j in M]
    discarded = falses(length(M))
    for m in 1:(length(M)+1-k)
        if discarded[m] continue end
        for mm in 1:(length(M)+1-k)
          if m == mm continue
          elseif discarded[mm] continue
          elseif issubset(map[mm],map[m])
            discarded[m] = true
            break
          elseif issubset(map[m],map[mm])
            discarded[mm] = true
            break
          end
        end
    end
    MM = [m for m in M if !discarded[m]]
    return MM
  end

  " For a given radius, test whether the associated covering problem is feasible using
  a MILP formulation with slack variables."
  function build_and_solve_covering_MIP(SS,MM,cov)
    time_remaining = TIME_LIM - (time()-STARTTIME)
    cover = create_model(time_remaining)
    @variable(cover, y[SS], Bin)
    @variable(cover, slack[MM] ≥ 0)
    @constraint(cover, covering[m in MM], sum(y[s] for s in SS if cov[s,m]) >= 1-slack[m]) # covering constraints
    @constraint(cover, lessthank, sum(y[s] for s in SS) == k) # cardinality constraint
    @objective(cover, Min, sum(slack[m] for m in MM))
    optimize!(cover)
    sol_used = []
    if termination_status(cover) == MOI.OPTIMAL
      for s in SS
        if value(y[s]) > 0.9
          push!(sol_used,s)
        end
      end
      return objective_value(cover),sol_used
    else
      return Inf,sol_used
    end
  end

  " Translate the binary search solution to a solution vector x."
  function compute_x_values(S, sol_items, solutions_used)::Array{Int64,2}
      x = zeros(k, data.n)
      k_ = 0
      for s in solutions_used
          k_ += 1
          for l in sol_items[S[s]]
              x[k_ ,l] = 1
          end
      end
      return x
  end

  S = 1:length(x_sol_array)
  M = 1:size(d,2)
  # Indicator for verifying if this is the last iteration of the algorithm
  # When last=true a feasible solution corresponding to the ub is calculated
  last = false
  # Count the number of iterations of the binary search algorithm
  ITER_BS = 0
  # Initialize the optimal solution vector
  x = []
  # The while loop is executed at least for the first and the last iteration
  # and until the convergence criteria on the relative gap is met
  while (ub - lb)/abs(ub) > ϵ_BS/100 || last || ITER_BS == 0
    ITER_BS += 1
    time()-STARTTIME > TIME_LIM && break

    if last
      # In the last iteraion r is set large enough to find a feasible solution
      r = ub
    else
      # Otherwise binary search classical update of r
      r = (lb+ub)/2
    end
    # A coverage matrix is built based on whether a solution covers a scenario with a cost <= r
    # For Smuggler, increase the precision to ϵ
    @timeit to "build cov" cov = [d[s,m] ≤ r+ϵ*abs(r) for s in S, m in M]
    if data.constraint_uncertainty
      for cons in 1:data.ncons
        # The objective coverage matrix is multiplied with the constraint coverage matrix to filter out infeasible solutions
        # (this might be sped-up by avoiding repeating 0 elements and using sparse representations)
        @timeit to "update cov" cov = cov .& a_cov[cons]
      end
    end
    infeasible = false
    # Non-dominated solutions and scenarios are filtered based on the coverage matrix
    @timeit to "dominance solutions" SS = calculate_nondom_solutions(cov,last,M,S)
    @timeit to "dominance scenarios" MM = calculate_nondom_scenarios(cov,M,S)
    # A MIP determining whether it is possible to cover all scenarios by choosing K solutions is solved
    # (notice only non-dominated scenarios and solutions are sent to this MIP)
    @timeit to "solve covering problem" objval,solutions_selected = build_and_solve_covering_MIP(SS,MM,cov)
    # If its optimal value is >= 1 then the MIP is infeasible
    infeasible = objval > 0.9
    if !infeasible
      # If the covering MIP is feasible then a feasible solution with value r can be found and therefore
      # the upper bound is updated
      ub = r
      if last
        # If this is the last iteration of the algorithm a feasible solution is returned
        x = compute_x_values(S, sol_items, solutions_selected)
        break
      end
    else
      # If the covering MIP is infeasible then the lower bound can be increased to r
      if last && objval < Inf
        @error "Shouldn't be here"
        exit()
      elseif last && objval >= Inf
        return [], lb, ub
      else
        lb = r
      end
    end
    # When convergence is achieved last iteration indicator is turned true and one last iteration of BS is done
    if (ub - lb)/abs(ub) ≤ ϵ_BS
      last = true
    end
  end
  # The algorithm returns with an optimal solution and a lower bound on the optimal master value
  # Note that if the algorithm is broken due to time limit restrictions then we return x=[]
  return x, lb, ub
end

#-----------------------------------------------------------------------------------

function update_d(x_sol_array,cc,d,S,M,NUMITER,hh)
  if NUMITER == 1
    for s in S, m in M
      d[s,m] = hh[s]*sum(x_sol_array[s][l]*cc[m,l] for l in N)
    end
  else
    new_costs = [hh[s]*sum(x_sol_array[s][l]*cc[length(M),l] for l in N) for s in S]
    d = [d new_costs]
  end
  return d
end

#-----------------------------------------------------------------------------------

function update_a(x_sol_array,aa,a_cov,S,M,NUMITER)
  if NUMITER == 1
    for cons in data.ncons, s in S, m in M
      a_cov[cons][s,m] = sum(x_sol_array[s][l]*aa[cons][m,l] for l in N) ≤ data.B[cons]
    end
  else
    for cons in data.ncons
      new_cov = [sum(x_sol_array[s][l]*aa[cons][length(M),l] for l in N) ≤ data.B[cons] for s in S]
      a_cov[cons] = [a_cov[cons] new_cov]
    end
  end
  return a_cov
end

#-----------------------------------------------------------------------------------

function calculate_d(x_sol_array,cc,S,M,hh)
  d = Matrix{Float64}(undef,length(S),length(M))
  for s in S, m in M
    d[s,m] = hh[s]*sum(x_sol_array[s][l]*cc[m,l] for l in N)
  end
  return d
end

#-----------------------------------------------------------------------------------

function calculate_a(x_sol_array,aa,S,M)
  a_cov = Vector{Matrix{Bool}}()
  for cons in 1:data.ncons
    push!(a_cov,Matrix{Bool}(undef,length(S),length(M)))
    for s in S, m in M
      a_cov[cons][s,m] = sum(x_sol_array[s][l]*aa[cons][m,l] for l in N) ≤ data.B[cons]
    end
  end
  return a_cov
end

#-----------------------------------------------------------------------------------

function find_new_solution(c_vec,a_vec,UB,fixedzero,fixedone,relax,bound,TIME)
  sol_model = create_model(TIME)
  if relax
    @variable(sol_model, 0<=x[i in N]<=1, container=Array)
  else
    @variable(sol_model, x[i in N], Bin, container=Array)
  end
  add_constraints_X(sol_model,x)
  if data.constraint_uncertainty
    @constraint(sol_model, [cons in 1:data.ncons], sum(a_vec[cons][i]*x[i] for i in N) ≤ data.B[cons] )
  end
  @constraint(sol_model,[i in fixedzero],x[i]==0)
  @constraint(sol_model,[i in fixedone],x[i]==1)
  if bound @constraint(sol_model,sum(x[i]*c_vec[i] for i in N) ≤ UB) end
  @objective(sol_model,Min,sum(x[i]*c_vec[i] for i in N))
  optimize!(sol_model)
  if termination_status(sol_model) == MOI.OPTIMAL
    return value.(x)
  else
    return []
  end
end

#-----------------------------------------------------------------------------------

function relax_and_fix(cc,aa,UB)
  fixedzero = []
  fixedone = []
  time_remaining = TIME_LIM-(time()-STARTTIME)
  @timeit to "relaxation" solution = find_new_solution(cc,aa,UB,fixedzero,fixedone,true,true,time_remaining)
  if size(solution,1) > 0
    for i in N
      if solution[i]>=1-ϵ
        push!(fixedone,i)
      elseif solution[i]<=ϵ
        push!(fixedzero,i)
      end
    end
    @timeit to "integer" solution = find_new_solution(cc,aa,UB,fixedzero,fixedone,false,false,time_remaining)
    if size(solution,1) > 0
      return solution
    else
      return []
    end
  else
    return []
  end
end


#-----------------------------------------------------------------------------------|
" Traslate the enumerated solutions (vector of bool) to solution vectors in 0/1 (x_sol_array). For each solution we also
store the vector of indices of the non-zero variables (sol_items)."
function fill_solutions_bit(solutions, x_sol_array, sol_items)
    S = 1:size(solutions,1)
    for s in S
        sol = zeros(data.n)
        for i in N
            if solutions[s][i]
              sol[i] = 1
            end
        end
        push!(x_sol_array, sol)
        items = Vector{Int}()
        for l in N
            if sol[l] == 1
                push!(items, l)
            end
        end
        push!(sol_items, items)
    end
end

#-----------------------------------------------------------------------------------

" Round the variable values that pass the solver tolerance checks."
function round_solution(sol)
  for i=1:length(sol)
    if sol[i] <= ϵ
      global sol[i] = 0
    elseif sol[i] >= 1-ϵ
      global sol[i]= 1
    end
  end
  return sol
end
